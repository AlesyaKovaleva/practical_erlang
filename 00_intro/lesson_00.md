# Обзор Эрланг

О правильном произношении:
Erlang -- англоговорящие ставят ударение на первый слог.
эрлАнг -- рускоговорящим удобнее ставить ударение на второй слог.


## Немного истории

Предыстория -- начало ХХ века
Детство     -- 1985-1991
Взросление  -- 1991-1998
Выход в мир -- с 1998 по настоящее время


### Прыдистория -- начало ХХ века

Агнер Краруп Эрланг
Agner Krarup Erlang

./agner_krarup_erlang.jpg

https://en.wikipedia.org/wiki/Agner_Krarup_Erlang

Датский математик, статистик и инженер.
Основатель научного направления по изучению трафика в телекоммуникационных системах.
Автор теории массового обслуживания.

Теория массового обслуживания (теория очередей)
Queueing theory
https://en.wikipedia.org/wiki/Queueing_theory

1909
научная работа
«Теория вероятностей и телефонные разговоры»
(The Theory of Probabilities and Telephone Conversations)
Признана во всем мире, принята для использования в крупнейшей почтовой службе мира — Главном почтамте Великобритании.

В его честь была названа единица измерения трафика в телекоммуникационных системах — эрланг.
Его теория до сих пор используются при расчётах пропускной способности современных телекоммуникационных сетей.
И не только телекоммуникационных, а любых сетей.
А также для оценки автомобильного траффика, при проектировании дорог.
А тажке при проектировании фабрик, складов, магазинов и больниц.


### Детство -- 1985-1991

Эрланг родился в недрах шведской компании Эрикссон (Ericsson) -- крупного поставщика телекомуникационного оборудования и услуг.

Сложная индустрия: сложное оборудование, сложный софт, большой траффик, жесткие требования по доступности сервиса.
Это был highload тех времен.

В компании был отдел, занимающийся научной работой:
Ericsson’s Computer Science Laboratory in Stockholm, Sweden.

Джо Армстронг (Joe Armstrong),
Роберт Вирдинг (Robert Virding)
и Майк Вильямс (Mike Williams)
под руководством Бьярне Деккера (Bjarne Däcker)

Отделу была поставлена задача найти более эффективные средсва разработки софта для железа и сервисов компании.
У компании уже был опыт разработки языков программирования,
использовались собственные проприетарные языки PLEX и EriPascal.
Но они не стремились разработать еще один язык, а хотели найти подходящее решение среди уже существующих.

В течение 2х лет отдел писал прототипы телеком-приложений на разных языках, имеющихся в то время:
- функциональные языки ML и Miranda
- многопоточные языки ADA, Modula и Chill
- Prolog
- Smalltalk

Больше всего им понравился Prolog. И первая виртуальная машина для Erlang была написана на нем.

Но разработчики пришли к выводу, что ни один язык не имеет нужного набора возможностей.
И главная проблема -- ни один язык не поддерживает многопоточность на нужном уровне.
И только через 2 года лаборатория решила разработать свой язык программирования.

Еще 4 года ушло на разработку первых версий Эрланг, одновременно с написанием прототипов приложений на нем.

В отличие от большинства языков программирования, разработанных для "общего" применения и на "правильном" теоретическом базисе,
Эрланг изначально разрабатывался для конкретного узкого применения, исходя из практических требований.
И от этого идут его преимущества и недостатки (о которых мы поговорим ниже).


### Взросление -- 1991-1998

По итогам 6-ти летней работы лаборатории Эрланг был признан удачным решением, соответствующим всем требованиям.
Но язык был слишком медленным. Так что в 1991 Майк Вильямс переписал виртуальную машину на С.

В 1992 году Erlang был впервые использован в коммерческом проекте, и проект завершился успешно.

В 1995 году случился провал крупного проекта на С++ по созданию нового маршрутизатора. Проект включал разработку и железа и софта.
Софт решили переписать заново на эрланге, и для этого создали новый отдел, куда вошло 60 разработчиков.
Отдел названи Open Telecom Platform (OTP). Вторая попытка оказалось успешна.

Этот проект включал больше 1М строк на эрланге.
В его рамках был разработан фреймворк OTP, нынче главный и единственный фреймворк для всех эрланг проектов.

Дальше дела пошли не так гладко. Топ-менеджмент Эрикссон вдруг решил, что будущее за Java.
Использование эрланг было запрещено в новых проектах.
Многие разработчики покинули Эрикссон и организовали собственную компанию,
где продолжали использовать эрланг. Компания оказалась успешной.
А через какое-то время и Эрикссон вернулись к эрланг, и используют его по сей день.

В 1998 эрланг был выпущен в open source, и стал известен за пределами Эрикссон.
Тогда к проекту подключился университет Уппсала (Uppsala University) -- старейший университет Швеции.
В университете была создана группа High-Performance Erlang research group (HiPE).
И они разработали компилятор в нативный код.


### Выход в мир -- с 1998 по настоящее время

Следующие несколько лет эрланг использовался в Эрикссон, и отдельными энтузиастами за пределами компании, но был мало известен.

Например, в 2002 году был начат проект ejabberd https://www.ejabberd.im/ -- первый крупный open source проект на эрланг.
Ставший основой для большинства IM (instant messaging) систем,
в т.ч. для широко известного нынче WhatsApp https://en.wikipedia.org/wiki/WhatsApp.

Его автор -- Алексей Щепин -- получил награду «User of the Year» на 2006 Erlang user conference

В 2006 году в эрланг появилась поддержка симметричной мультипроцессорности (Symmetric Multiprocessing, SMP).
https://en.wikipedia.org/wiki/Symmetric_multiprocessing
Эрланг научился эффективно использовать все имеющиеся в системе процессорные ядра.

И это случилось в подходящий момент. К этому времени производители процессоров достигли предела тактовых частот.
Дальше наращивать мощность одного процессора было невозможно, и производители пошли по пути увеличения числа процессоров.
А у IT-индустрии появилась потребность разрабатывать многопоточные программы, эффективно использующие несколько процессоров.
Делать это на популярных языках программирования было трудно, и возник интерес к функциональному программированию вообще,
и к эрланг в частности.

Эта популярность проявилась в двух направлениях:
- использование самих ФП языков;
- заимствование идей ФП и реализация их в популярных языках.

В 2007 вышла книга Джо Армстронга "Programming Erlang".

Нынче эрланг известен и применяется достаточно широко.


## Важные особенности Erlang

Изначально, еще до разработки эрланг, были сформулированы требования к языку:
- Concurrency -- эффективная реализация многопоточности
- Fault Tolerance -- устойчивость к программным и аппаратным сбоям
- Distribution -- поддержка распределенных систем
- Hot Code Upgrade -- возможность горячего обновления кода

К этим 4-м столпам, описанным во всех книгах по эрланг, я добавлю еще несколько фич:
- Symmetric Multiprocessing
- Actor Model
- Soft Real Time
- Garbage Collection
- Erlang Shell
- Tracing

Сердцем Erlang является Erlang Run-Time System (ERTS) -- виртуальная машина, которая выполняет байт-код эрланг.
Реализована на С, и все описаные ниже фичи обеспечиваются ей.


### Concurrency

Процессы являются базовой сущностью языка.

Процессы легковесны, их можно создавать десятки и сотни тысяч. Переключение между ними очень быстрое.

Нет разделяемой области памяти, каждый процесс имеет свою изолированную память.

Ошибки в процессах также изолированны, краш одного процесса не влияет на работу остальных.

Данные между процессами передаются путем "отправки сообщений" (message passing).
При этом данные копируются из памяти одного процесса в память другого.

1024 - 134,217,727 (2^10 - 2^27)
дефолтное значение 262,144 (2^18)

Запуск нового потока - 3-5 микросекунд.

На старте поток занимает 2696 байт, включая стек, кучу и память под свои метаданные
(потом резервирует больше памяти, если нужно).

Запускается несколько планировщиков, соответственно количеству процессорных ядер.
Каждый планировщик использует один процесс ОС, и поверх него запускает эрланговские процессы.

Планировщики умеюют балансировать нагрузку, перераспределяя потоки между собой.
У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров,
но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.

Lukas Larsson - Understanding the Erlang Scheduler
https://www.youtube.com/watch?v=tBAM_N9qPno


### Fault Tolerance

Большинство языков для этого предлагает механизм исключений. И
разработчик может получить относительно безопасный код, если правильно
расставит try…catch и правильно обработает ошибки.

В Erlang это тоже есть, но это только первый уровень изоляции
ошибок. И он довольно редко используется, из-за того, что другие
уровни работают хорошо. Если вы возьмете исходники какого-нибудь
крупного известного эрланг проекта, например, cowboy или riak, и
поищите там try..catch, то найдете их очень мало.

Вторым уровнем является дерево супервизоров. В Erlang есть специальные
потоки, которые сами не выполняют полезной работы, а наблюдают за
другими. Такие специальные потоки называются supervisor
(наблюдатели). Ну а потоки, которые выполняют реальную работу,
называются worker (рабочие).

Если в рабочем потоке возникает ошибка, он аварийно
завершается. Супервизор получает об этом сообщение, и может принять
какие-то меры. Стандартная мера – логировать ошибку и перезапустить
рабочий поток заново. При этом мы имеем небольшие потери (текущее
состояние потока), но можем продолжать работу.

Супервизоры наблюдают не только за рабочими процессами, но и друг за
другом. Для этого все потоки организованы в дерево, где узлами
являются супервизоры, а листьями – рабочие потоки.  В более сложной
ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И,
наконец, все дерево целиком.

Третий уровень изоляции ошибок – объединение нод в кластер. Если нода
все-таки падает, или вообще сервер выходит из строя из-за проблем с
железом, то ее функцию может взять на себя резервная нода.


### Distribution

A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.
Leslie Lamport.

Устойчивость в т.ч. и к аппаратным авариям является одним из требований к эрланг.
И обеспечить эту устойчивость можно только в распределенной системе.

Железо выходит из строя не так часто, но это случается.
Если инфраструктура состоит из сотен серверов, то это случается регулярно, и является штатной ситуацией.

2 цели:
- горизонтальное масштабирование
- устойчивость к авариям

Сетевая прозрачность (location transparency)

Процессы общаются отправкой сообщений друг другу, при этом не важно,
находятся ли они на одном узле, или на разных.

За реализацию отвечает виртуальная машина. Она сама открывает сокеты,
устанавливает нужные TCP соединения между узлами, мониторит их
состояние – программисту об этих низкоуровневых вещах думать не нужно.

Сетевая прозрачность касается не только отправки сообщений, но и мониторинга процессов.
supervisor может мониторить worker на другом узле

Erlang-узлы, собранные в кластер, формируют доверенную среду (trusted
environment), без ограничения прав. Любой процесс может посылать любые
сообщения кому угодно. Это удобно, не безопасно. Подразумевается, что
все узлы находятся в одной локальной сети, и сеть защищена от внешнего
мира.


### Hot Code Upgrade

Эрланг позволяет загрузить в рантайм новую версию кода модуля,
и переключить выполнение процесса со старой версии на новую.

Ситуация может осложнятся тем, что изменились структуры данных,
и нужно мигрировать данные из старой структуры в новую.

Или может измениться дерево супервизоров, и нужно стартовать новые процессы,
или завершить старые.

Эти проблемы так или иначе решаются.


### Symmetric Multiprocessing

С 2006 года одна эрланговская нода умеет эффективно использовать все процессорные ядра в системе,
и перераспределять нагрузку между ними.

То есть, процесс, запущенный под одним планировщиком, на одном процессорном ядре, может быть
передан под управление другому планировщику, и продолжить выполнение на другом процессором ядре.

Это позволяет избежать ситуаций, когда одно ядро загружено на 100%, а другое простаивает.

Причем, это справедливо для систем с большим количеством ядер. Например, его запускали
на чипах с 1024 ядрами, и эрланг эффективно использовал ресурс всех этих ядер.

Erlang Scheduler Details and Why It Matters
https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html


### Actor Model

https://en.wikipedia.org/wiki/Actor_model

Один из способов реализации многопоточности.

Система состоит из акторов, которые действуют паралельно и независимо друг от друга.

Акторы общаются друг с другом с помощью отправки сообщений (message passing).
Один поток может послать другому любые данные.
При этом данные копируются, и получающий поток никак не может повлияют на данные отправителя.

Отправка сообщений является асинхронной.
При необходимости можно реализовать синхронный вызов -- блокировать процесс на какое-то время, и ждать, пока придет ответное сообщение.

Каждый процесс имеет специальную область памяти -- mailbox, где накапливаются полученные им сообщения.
Процесс проверяет свой mailbox, когда считает нужным, и реагирует на сообщения, как считает нужным.

Для некоторых языков модель акторов реализована как библиотека.
Например, библиотека Akka http://akka.io/ для Scala и Java.

Но в эрланг эта модель реализована в его виртуальной машине и поддерживается непосредственно на уровне языка.


### Soft Real Time

https://en.wikipedia.org/wiki/Real-time_computing

На эрланг можно строить системы реального времени -- то есть, системы, где требуется предсказуемое время ответа.

Это возможно благодаря:
- вытесняющей многозадачности (preemptive scheduling);
- настраиваемому IO;
- особенностям сборки мусора (garbage collection).

Да, планировщики в эрланг реализуют вытесняющую многозадачность.

IO не выполняется в каждом процессе отдельно, а выполняется через специализированный пул процессов,
и его можно тонко настраивать.

Про сборку мусора поговорим отдельно.


### Garbage Collection

Сборка мусора в функциональных языках несколько проще, чем в
императивных, благодаря неизменяемым переменным.  Из-за этого точно
известно, что переменные, созданные раньше, не могут указывать на
объекты, созданные позже.

Сборщик мусора в Erlang делит объекты на два поколения: молодые и
старые. И исходит из предположения, что большинство молодых объектов
являются короткоживущими, и для них память нужно чистить чаще. А
большинство старых объектов являются долгоживущими, и для них память
можно чистить реже.

В этом нет ничего особенного, во многих других языках сборка мусора работает аналогично.

А вот что в эрланг особенного, это отдельный сборщик мусора для каждого потока.
И отсюда отсутствие эффекта stop world, когда сборщик мусора должен остановить всю ноду для своей работы.

В Erlang все сборщики работают независимо друг от друга, в разные моменты времени, и останавливают только свой поток.

Если поток короткоживущий (что довольно обычно для Erlang),
то после его завершения вся память потока целиком освобождается, а сборщик мусора даже не успевает поработать.

Если поток долгоживущий, но потребляет мало памяти (типично для супервизора и других потоков, выполняющих "менеджерские" задачи),
то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.

Erlang Garbage Collection Details and Why It Matters
https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html


### Erlang Shell

Как и многие другие языки, эрланг имеет REPL консоль.
Ей удобно пользоваться при разработке.

Но ей можно пользоваться и в продакшен. Можно подключиться к работающей ноде,
вызывать любую функцию любого модуля, отправить сообщение любому процессу,
прочитать и изменить состояние любого процесса -- то есть,
взаимодействовать с нодой в реальном времени.

Это очень помогает в диагностике разных проблем и исправлении их налету.


### Tracing

В эрланг есть встроенный на самом низком уровне механизм трассировки,
мало влияющий на общую производительность системы. Поэтому его можно
использовать на живой, продакшен системе.

Этот механизм позволяет получать в реальном времени информацию:
- жизненный цикл процессов (старт, остановка, связи с другими процессами);
- отправка и получение сообщений;
- вызовы функций, аргументы, возвращаемые значения, откуда вызвана;
- наблюдать состояние процессов, и менять его;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе ноды. Практически этой
информации очень много, и сложность в том, чтобы выбрать именно ту, которая важна.

Данные трассировки можно наблюдать в консоли, или перенаправить в
файл, или в свой обработчик. Ее можно получать на той же ноде, или
перенаправить на другую ноду, и обрабатывать и анализировать там.


## Сфера применения

Самая подходящая сфера применения для эрланг, это сервер, обслуживающий много *долгоживущих* соединений.

Обслуживать много соединений умеют многие. Если это короткие соединения, как, например, HTTP-запрос.
Но все становится сложнее, если эти соединение долгоживущие. На эрланг такую задачу решать проще.

Классический пример таких серверов -- это Instant Messaging и многопользовательский чат.
Не зря история не-эрикссоновского эрланга началась с ejabberd.
Facebook chat начинался с эрланг (сейчас там Scala).

И, конечно, нашумевшая история WhatsUp https://habrahabr.ru/post/276951/

19 февраля 2014 года Facebook купил WhatsApp за 19 млрд долл.
На март 2015 при помощи WhatsApp пересылалось более 50 млрд сообщений.
В начале февраля 2016 года в собственном блоге основатели WhatsApp заявили,
что сервис преодолел планку в 1 миллиард пользователей.

Не редко эрланг является основным или, как минимум, важным компонентом Cloud Platform.
В этой роли его используют Amazon, Yahoo, Heroku, Github.

Для многих (в т.ч. для Wargaming) знакомство с эрланг начинается с RabbitMQ.
Полезный инструмент, мы в Wargaming используем его очень широко.

Распределенные базы данных: Riak, CouchDB.


## Применение в вебе

Первое поколение:
Веб сервера: YAWS, Mochiweb
Фреймворки: Chicago Boss, Nitrogen, N2O

Второе поколение:
Веб сервер: Cowboy
Фреймворки: нет

Почему нет фреймворков? Во-первых, оказалось, что на эрланг трудно сделать что-то похожее на Ruby on Rails или Django.
Во-вторых, появился Elixir.

Бэкенд сервисы, которые непосредственно с пользователем не работают, UI для него не генерируют,
но предоставляют API для клиентских компонентов. Это может быть HTTP API, или не HTTP.
Клиентом может быть JS-приложение в браузере, или мобильное приложение, или другой бэкенд сервис.

Те, кому нужен такой веб, как Ruby on Rails или Django, направили усилия на Elixir / Phoenix.

Третье поколение:
Elixir/Phoenix
и за ним будущее.


## Недостатки

Главный недостаток любого не мейнстримового языка -- малое количество разработчиков.
Для компании, которая решится использовать эрланг в своем бизнесе, это серьезный риск.
Фейсбук именно поэтому отказался от эрланг.

Из-за малого количества компаний мало вариантов для разработчиков.
Для разработчика инвестировать много времени и глубоко изучить язык -- тоже риск.
Лучше сохранять компетенцию в других, более популярных языках, чтобы иметь больше вариантов трудоустройства.

Порочный круг: нет компаний, потому что нет разработчиков. Нет разработчиков, потому что нет компаний.
Круг разрывается за счет энтузиастов (обычно разработчиков), которые вкладывают свои усилия,
не расчитывая, что это оправдается коммерчески.

Мало библиотек и еще меньше качественных библиотек.
Многие библиотеки не качествены, слабо документированы, часто не имеют нормальной версионности.

Динамическая типизация. Тут вопрос, конечно, спорный. Но лично я бы предпочел статическую типизацию.
dialyzer есть, но он необязательный, и с ним есть свои нюансы. Все-таки, это штука приделанная сбоку,
а не естественная часть языка.

Язык консервативный и развивается очень медленно. Например, тип map внедряли несколько лет.
Развивается он не путем добавления новых фич, а путем шлифовки того, что уже есть.
Лично мне это нравится.

Для веб-разработчиков, привыкших к Ruby on Rails, эрланг и его инфраструктура (библиотеки, инструменты)
слишком бедный, и слишком низкоуровневый.


## Уровни изучения эрланг

Из книги Фреда:
The 9th Circle of Erl
./9-circles-of-erl.png
