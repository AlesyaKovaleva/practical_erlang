# Обзор Эрланг

О правильном произношении:
Erlang -- англоговорящие ставят ударение на первый слог.
эрлАнг -- рускоговорящим удобнее ставить ударение на второй слог.


## Немного истории

Предыстория -- начало ХХ века
Детство     -- 1985-1991
Взросление  -- 1991-1998
Выход в мир -- с 1998 по настоящее время


### Прыдистория -- начало ХХ века

Агнер Краруп Эрланг
Agner Krarup Erlang

./agner_krarup_erlang.jpg

https://en.wikipedia.org/wiki/Agner_Krarup_Erlang

Датский математик, статистик и инженер.
Основатель научного направления по изучению трафика в телекоммуникационных системах.
Автор теории массового обслуживания.

Теория массового обслуживания (теория очередей)
Queueing theory
https://en.wikipedia.org/wiki/Queueing_theory

1909
научная работа
«Теория вероятностей и телефонные разговоры»
(The Theory of Probabilities and Telephone Conversations)
Признана во всем мире, принята для использования в крупнейшей почтовой службе мира — Главном почтамте Великобритании.

В его честь была названа единица измерения трафика в телекоммуникационных системах — эрланг.
Его теория до сих пор используются при расчётах пропускной способности современных телекоммуникационных сетей.
И не только телекоммуникационных, а любых сетей.
А также для оценки автомобильного траффика, при проектировании дорог.
А тажке при проектировании фабрик, складов, магазинов и больниц.


### Детство -- 1985-1991

Эрланг родился в недрах шведской компании Эрикссон (Ericsson) -- крупного поставщика телекомуникационного оборудования и услуг.

Сложная индустрия: сложное оборудование, сложный софт, большой траффик, жесткие требования по доступности сервиса.
Это был highload тех времен.

В компании был отдел, занимающийся научной работой:
Ericsson’s Computer Science Laboratory in Stockholm, Sweden.

Джо Армстронг (Joe Armstrong),
Роберт Вирдинг (Robert Virding)
и Майк Вильямс (Mike Williams)
под руководством Бьярне Деккера (Bjarne Däcker)

Отделу была поставлена задача найти более эффективные средсва разработки софта для железа и сервисов компании.
У компании уже был опыт разработки языков программирования,
использовались собственные проприетарные языки PLEX и EriPascal.
Но они не стремились разработать еще один язык, а хотели найти подходящее решение среди уже существующих.

В течение 2х лет отдел писал прототипы телеком-приложений на разных языках, имеющихся в то время:
- функциональные языки ML и Miranda
- многопоточные языки ADA, Modula и Chill
- Prolog
- Smalltalk

Больше всего им понравился Prolog. И первая виртуальная машина для Erlang была написана на нем.

Но разработчики пришли к выводу, что ни один язык не имеет нужного набора возможностей.
И главная проблема -- ни один язык не поддерживает многопоточность на нужном уровне.
И только через 2 года лаборатория решила разработать свой язык программирования.

Еще 4 года ушло на разработку первых версий Эрланг, одновременно с написанием прототипов приложений на нем.

В отличие от большинства языков программирования, разработанных для "общего" применения и на "правильном" теоретическом базисе,
Эрланг изначально разрабатывался для конкретного узкого применения, исходя из практических требований.
И от этого идут его преимущества и недостатки (о которых мы поговорим ниже).


### Взросление -- 1991-1998

По итогам 6-ти летней работы лаборатории Эрланг был признан удачным решением, соответствующим всем требованиям.
Но язык был слишком медленным. Так что в 1991 Майк Вильямс переписал виртуальную машину на С.

В 1992 году Erlang был впервые использован в коммерческом проекте, и проект завершился успешно.

В 1995 году случился провал крупного проекта на С++ по созданию нового маршрутизатора. Проект включал разработку и железа и софта.
Софт решили переписать заново на эрланге, и для этого создали новый отдел, куда вошло 60 разработчиков.
Отдел названи Open Telecom Platform (OTP). Вторая попытка оказалось успешна.

Этот проект включал больше 1М строк на эрланге.
В его рамках был разработан фреймворк OTP, нынче главный и единственный фреймворк для всех эрланг проектов.

Дальше дела пошли не так гладко. Топ-менеджмент Эрикссон вдруг решил, что будущее за Java.
Использование эрланг было запрещено в новых проектах.
Многие разработчики покинули Эрикссон и организовали собственную компанию,
где продолжали использовать эрланг. Компания оказалась успешной.
А через какое-то время и Эрикссон вернулись к эрланг, и используют его по сей день.

В 1998 эрланг был выпущен в open source, и стал известен за пределами Эрикссон.
Тогда к проекту подключился университет Уппсала (Uppsala University) -- старейший университет Швеции.
В университете была создана группа High-Performance Erlang research group (HiPE).
И они разработали компилятор в нативный код.


### Выход в мир -- с 1998 по настоящее время

Следующие несколько лет эрланг использовался в Эрикссон, и отдельными энтузиастами за пределами компании, но был мало известен.

Например, в 2002 году был начат проект ejabberd https://www.ejabberd.im/ -- первый крупный open source проект на эрланг.
Ставший основой для большинства IM (instant messaging) систем,
в т.ч. для широко известного нынче WhatsApp https://en.wikipedia.org/wiki/WhatsApp.

Его автор -- Алексей Щепин -- получил награду «User of the Year» на 2006 Erlang user conference

В 2006 году в эрланг появилась поддержка симметричной мультипроцессорности (Symmetric Multiprocessing, SMP).
https://en.wikipedia.org/wiki/Symmetric_multiprocessing
Эрланг научился эффективно использовать все имеющиеся в системе процессорные ядра.

И это случилось в подходящий момент. К этому времени производители процессоров достигли предела тактовых частот.
Дальше наращивать мощность одного процессора было невозможно, и производители пошли по пути увеличения числа процессоров.
А у IT-индустрии появилась потребность разрабатывать многопоточные программы, эффективно использующие несколько процессоров.
Делать это на популярных языках программирования было трудно, и возник интерес к функциональному программированию вообще,
и к эрланг в частности.

Эта популярность проявилась в двух направлениях:
- использование самих ФП языков;
- заимствование идей ФП и реализация их в популярных языках.

В 2007 вышла книга Джо Армстронга "Programming Erlang".

Нынче эрланг известен и применяется достаточно широко.


## Важные особенности Erlang

Изначально, еще до разработки эрланг, были сформулированы требования к языку:
- Concurrency -- эффективная реализация многопоточности
- Fault Tolerance -- устойчивость к программным и аппаратным сбоям
- Distribution -- поддержка распределенных систем
- Hot Code Upgrade -- возможность горячего обновления кода

К этим 4-м столпам, описанным во всех книгах по эрланг, я добавлю еще несколько фич:
- Symmetric Multiprocessing
- Actor Model
- Soft Real Time
- Garbage Collection
- Erlang Shell
- Tracing

Сердцем Erlang является Erlang Run-Time System (ERTS) -- виртуальная машина, которая выполняет байт-код эрланг.
Реализована на С, и все описаные ниже фичи обеспечиваются ей.


### Concurrency

Процессы являются базовой сущностью языка.

Процессы легковесны, их можно создавать десятки и сотни тысяч. Переключение между ними очень быстрое.

Нет разделяемой области памяти, каждый процесс имеет свою изолированную память.

Ошибки в процессах также изолированны, краш одного процесса не влияет на работу остальных.

Данные между процессами передаются путем "отправки сообщений" (message passing).
При этом данные копируются из памяти одного процесса в память другого.

1024 - 134,217,727 (2^10 - 2^27)
дефолтное значение 262,144 (2^18)

Запуск нового потока - 3-5 микросекунд.

На старте поток занимает 2696 байт, включая стек, кучу и память под свои метаданные
(потом резервирует больше памяти, если нужно).

Запускается несколько планировщиков, соответственно количеству процессорных ядер.
Каждый планировщик использует один процесс ОС, и поверх него запускает эрланговские процессы.

Планировщики умеюют балансировать нагрузку, перераспределяя потоки между собой.
У них нет задачи постоянно держать равномерную нагрузку на все ядра процессоров,
но есть задача избежать больших перекосов, когда одно ядро загружено на 100%, а другое вообще простаивает.

Lukas Larsson - Understanding the Erlang Scheduler
https://www.youtube.com/watch?v=tBAM_N9qPno


### Fault Tolerance

Большинство языков для этого предлагает механизм исключений. И
разработчик может получить относительно безопасный код, если правильно
расставит try…catch и правильно обработает ошибки.

В Erlang это тоже есть, но это только первый уровень изоляции
ошибок. И он довольно редко используется, из-за того, что другие
уровни работают хорошо. Если вы возьмете исходники какого-нибудь
крупного известного эрланг проекта, например, cowboy или riak, и
поищите там try..catch, то найдете их очень мало.

Вторым уровнем является дерево супервизоров. В Erlang есть специальные
потоки, которые сами не выполняют полезной работы, а наблюдают за
другими. Такие специальные потоки называются supervisor
(наблюдатели). Ну а потоки, которые выполняют реальную работу,
называются worker (рабочие).

Если в рабочем потоке возникает ошибка, он аварийно
завершается. Супервизор получает об этом сообщение, и может принять
какие-то меры. Стандартная мера – логировать ошибку и перезапустить
рабочий поток заново. При этом мы имеем небольшие потери (текущее
состояние потока), но можем продолжать работу.

Супервизоры наблюдают не только за рабочими процессами, но и друг за
другом. Для этого все потоки организованы в дерево, где узлами
являются супервизоры, а листьями – рабочие потоки.  В более сложной
ситуации можно перегрузить всю ветвь дерева, выше и выше по уровню. И,
наконец, все дерево целиком.

Третий уровень изоляции ошибок – объединение нод в кластер. Если нода
все-таки падает, или вообще сервер выходит из строя из-за проблем с
железом, то ее функцию может взять на себя резервная нода.


### Distribution

Программировать распределенные системы сложно на любом языке. Но
Erlang делает это немного проще, т.к. изначально разрабатывался для
этого.

TODO stopped here

2 цели:
- горизонтальное масштабирование
- устойчивость к авариям

На уровне языка действует все тот же message passing, причем нет
никакой разницы, находятся ли процессы на одной машине, или на
разных. Все машины действуют в едином информационном пространстве, и
любой процесс может вызывать любые модули и посылать сообщения любым
процессам. Такая фича называется location transparency.

На ряду с программными проблемами бывают и аппаратные. Иногда железо
выходит из стороя. А если инфраструктура состоит из сотен серверов, то
это случается регулярно, и является штатной ситуацией.

Устойчивость в т.ч. и к аппаратным авариям является одним из требований к эрланг.
И обеспечить эту устойчивость можно только в распределенной системе.


### Hot Code Upgrade

Подробнее рассмотрим, когда будем изучать gen_server.


### Symmetric Multiprocessing

SMP

### Actor Model

Многопоточность и модель акторов.

message passing -- общение между потоками передачей сообщений. Один поток может послать другому любые данные.
При этом данные копируются, и получающий поток никак не может повлияют на данные отправителя.

Отправка сообщения является асинхронной операцией.
При необходимости можно реализовать синхронный вызов -- блокировать процесс на какое-то время, и ждать, пока придет ответное сообщение.

Каждый процесс имеет специальную область памяти -- mailbox, где накапливаются полученные им сообщения.

TODO: Модель акторов в других языках: akka scala/java. Что еще?

Бартож Милевский. Теория категорий для программистов.
Композиция компонентов, и особенно композиция многопоточных компонентов, с гарантиями правильности от компилятора.
Так вот, в akka с этими гарантиями дела обстоят не важно.


### Soft Real Time

Программы на высокоуровневом языке Erlang могут быть использованы в системах мягкого реального времени (которое иногда переводят как «псевдореальное» или «квазиреальное»[31]). Автоматизированное управление памятью и сборка мусора действуют в рамках одного процесса, что даёт возможность создавать системы с миллисекундным временем отклика (даже несмотря на необходимость сборки мусора), не испытывающие ухудшения пропускной способности при высокой нагрузке[32].

Это не типично для систем с автоматической сборкой мусора. Почему сборка мусора не мешает soft real time? Об этом ниже.


### Garbage Collection

Сборка мусора в функциональных языках несколько проще, чем в императивных, благодаря неизменяемым переменным.
Из-за этого точно известно, что переменные, созданные раньше, не могут указывать на объекты, созданные позже.

Сборщик мусора в Erlang делит объекты на два поколения: молодые и
старые. И исходит из предположения, что большинство молодых объектов
являются короткоживущими, и для них память нужно чистить чаще. А
большинство старых объектов являются долгоживущими, и для них память
можно чистить реже.

Отдельный сборщик мусора для каждого потока. Нет эффекта stop world,
как в JVM, когда сборщик мусора нужно остановить всю ноду для своей
работы. В Erlang все сборщики работают независимо друг от друга, в
разные моменты времени, и останавливают только свой поток.

Если поток короткоживущий (что довольно обычно для Erlang), то после его завершения вся память потока целиком освобождается, а сборщик мусора даже не успевает поработать.

Если поток долгоживущий, но потребляет мало памяти (типично для супервизора и других потоков, выполняющих "менеджерские" задачи), то в нем сборщик мусора запускается очень редко, или никогда.

В результате сборка мусора оказывает мало влияния на производительность системы.


### Erlang Shell

REPL консоль при разработке

Есть возможность подключиться к работающей ноде, выполнять из консоли любой код, и модифицировать код налету.


### Tracing

В эрланг есть встроенный на самом низком уровне механизм трассировки,
мало влияющий на общую производительность системы. Поэтому его можно
использовать на живой, продакшен системе.

Этот механизм позволяет получать в реальном времени информацию:
- жизненный цикл процессов (старт, остановка, связи с другими процессами);
- отправка и получение сообщений;
- вызовы функций, аргументы, возвращаемые значения, откуда вызвана;
- наблюдать состояние процессов, и менять его;
- информацию о работе планировщика;
- информацию о потреблении памяти и работе сборщиков мусора.

Теоретически можно узнать почти все о работе ноды. Практически этой
информации очень много, и нужно уметь выбрать именно ту, которая важна.

Данные трассировки можно наблюдать в консоли, или перенаправить в
файл, или в свой обработчик. Ее можно получать на той же ноде, или
перенаправить на другую ноду, и обрабатывать и анализировать там.


## Сфера применения

Сервер, обслуживающий много *долгоживущих* соединений.
Классика -- Чаты

Rich Internet Application на веб сокетах
Веб-сервися, базы данных, многопользовательские игры

Долгоживущие клиент-сервеные соединения и большое к-во клиентов -- почему это проблема для многих языков/платформ.
Instante messaging.

Cloud Platforms
Messaging
Games
Databases


## Применение в вебе

Mochiweb, ChicagoBoss (первая попытка сделать рельсы), N2O -- вымершее поколение
Cowboy -- это не веб сервер, но не веб фреймворк. Годится для веб-сервисов, где не нужен фронтэнд.
Elixir Phoenix (рельсы возвращаются) -- за этим будущее


## Недостатки

Главный недостаток любого не мейнстримового языка -- малое количество разработчиков.
Для компании, которая решится использовать эрланг в своем бизнесе, это серьезный риск.
Фейсбук именно поэтому отказался от эрланг.

Из-за малого количества компаний мало вариантов для разработчиков.
Для разработчика инвестировать много времени и глубоко изучить язык -- тоже риск.
Лучше сохранять компетенцию в других, более популярных языках, чтобы иметь больше вариантов трудоустройства.

Мало библиотек и еще меньше качественных библиотек.
Многие библиотеки не качествены, слабо документированы, часто не имеют нормальной версионности.

Динамическая типизация. Тут вопрос, конечно, спорный. Но лично я бы предпочел статическую типизацию.
dialyzer есть, но он необязательный, и с ним есть свои нюансы. Все-таки, это штука приделанная сбоку,
а не естественная часть языка.

Язык консервативный и развивается очень медленно. Например, тип map внедряли несколько лет.

Для веб-разработчиков, привыкших к Python/Django или Ruby/Ruby on Rails эрланг и его инфраструктура (библиотеки, инструменты)
слишком бедный, и слишком низкоуровневый. Эта проблема решается очень медленно.
К счастью, для них есть Elixir, который развивается гораздо быстрее.


## Известные проекты

ejabberd
RabbitMQ
Riak
CouchDB
Cowboy

еще

WhatsApp
https://habrahabr.ru/post/276951/

на март 2015 при помощи WhatsApp пересылалось более 50 млрд сообщений.
19 февраля 2014 года Facebook купил WhatsApp за 19 млрд долл.
В начале февраля 2016 года в собственном блоге основатели WhatsApp заявили, что сервис преодолел планку в 1 миллиард пользователей
В 2012 достигли 2х миллиона активных TCP соединений на одном сервере.
Стандартный сервер, работающий с пользователями:
Два 6-ядерных процессора архитектуры Westmere.
100GB RAM, SSD

Amazon
Yahoo
Heroku
Github

Facebook Chat был написан в 2009 на Erlang, но впоследствии от этого языка отказались, так как было сложно найти квалифицированных программистов.

TODO у меня есть отдельный пост в блоге про это


## Уровни изучения эрланг

Из книги Фреда:
The 9th Circle of Erl
./9-circles-of-erl.png
